### 使用包 ###
    对于一个需要实际应用的模块而言，往往会具有很多程序单元，包括变量 、 函数和类等，
如果将整个模块的所有内容都定义在同一个 Python 源文件中，这个文件将会变得非常庞大，显然并不利于模块化开发 。

1. 什么是包
为了更好地管理多个模块源文件 ，Python 提供了包的概念。 那么问题来了，什么是包呢？
》从物理上看，包就是一个文件夹，在该文件夹下包含了 一个__init__.py 文件，该文件夹可用于包含多个模块源文件。
》从逻辑上看，包的本质依然是模块 。
    根据上面介绍可以得到一个推论：包的作用是包含多个模块，但包的本质依然是模块，因此包也可用于包含包。
典型地， 当我们为 Python 安装了 numpy 模块之后，可以在 Python 安装目录的 Lib\site-packages 目录下找到一个 numpy 文件夹，它就是前面安装的 numpy 模块（其实是一个包）。
在 numpy 包（也是模块）下既包含了 matlib.py 等模块源文件，也包含了 core 等子包（ 也是模块）。这正对应了我们刚刚介绍的：包的本质依然是模块，因此包又可以包含包。

2. 定义包
定义包更简单，主要有两步 。
(1) 创建一个文件夹，该文件夹的名字就是该包的包名。
(2) 在该文件夹内添加一个__init__.py 文件即可。
先新建一个 first_package 文件夹，然后在该文件夹中添加一个__init__.py 文件

与模块类似的是，包被导入之后，会在包目录下生成一个__pycache__文件夹，并在该文件夹内为包生成一个__init__.cpython-36（8）.pyc 文件。
    由于导入包就相当于导入该包下的__init__.py 文件，因此我们完全可以在__init__.py 文件中定
义变量、函数、类等程序单元，但实际上往往并不会这么做。想一想原因是什么？包的主要作用是包含多个模块，
因此一init_.py 文件的主要作用就是导入该包内的其他模块。

下面再定义一个更加复杂的包，在该包下将会包含多个模块，并使用__init__.py 文件来加载这些模块。
新建一个 fk_package 包，并在该包下包含三个模块文件 。
> print_shape.py
> billing.py
> arithmetic_chart.py
fk_package 的文件结构如下：
fk_package
    |--- arithmetic_chart.py
    |--- billing.py
    |--- print_shape.py
    L--- __init__.py

3. 导入包内成员
如果需要使用 arithmetic_chart 、 billing 和 print_shape 这三个模块，则可以在程序中执行如下导入代码(见 09\9.3\fk_package_test1.py) 。
上面程序虽然可以正常运行，但此时存在两个问题。
〉为了调用包内模块中的程序单元，需要使用很长的前缀，这实在是太麻烦了。
〉包内__init__.py 文件的功能完全被忽略了。
想一想就知道：包内的__init__.py 文件并不是用来定义程序单元的，而是用于导入该包内模块的成员，
这样即可把模块中的成员导入变成包内成员，以后使用起来会更加方便。
将 fk_package 包下的__init__.py 文件编辑成如下形式。（见09\9.3\fk_package＼__init__.py）

导入定义的包并使用 ：09\9.3\fk_package_test2.py