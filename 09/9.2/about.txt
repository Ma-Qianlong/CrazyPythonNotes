加载模块：

为了让 Python 能找到我们编写 （或第三方提供） 的模块，可以用以下两种方式来告诉它。
〉使用环境变量。
〉将模块放在默认的模块加载路径下。
使用环境变量...
Python 将会根据 PYTHONPATH 环境变量的值来确定到哪里去加载模块。
PYTHONPATH 环境变量的值是多个路径的集合，这样 Python 就会依次搜索 PYTHONPATH 环境变量所指定的多个路
径，试图从中找到程序想要加载的模块 。

默认的模块加载路径:
如果要安装某些通用性模块，比如复数功能支持的模块、矩阵计算支持的模块、图形界面支持
的模块等，这些都属于对 Python 本身进行扩展的模块，这种模块应该直接安装在 Python 内部，以
便被所有程序共享 ，此时就可借助于 Python 默认的模块加载路径。
Python 默认的模块加载路径由 sys.path 变量代表 ， 因此可通过在交互式解释器 中执行如下命令
来查看 Python 默认的模块加载路径。
>>> import sys, pprint
>>> pprint.pprint(sys.path)
上面代码使用 pprint 模块下的 pprint（）函数代替普通的 print（）函数，这是因为如果要打印的内 容
很多，使用 pprint 可以显示更友好的打印结果。
通常来说，我们应该将 Python的扩展模块添加在 lib\site-packages 路径下，它专门用于存放 Python 的扩展模块和包 。

导入模块的本质：
    使用“import fk_module”导入模块的本质就是： 将 fk module.py 中的全部代码加载到内存并执行，
然后将整个模块内容赋值给与模块同名的变量，该变量的类型是 module，而在该模块中定义的所有程序单元都相当于该 module 对象的成员。
    即使使用 from...import 只导入模块中部分成员 ， 该模块中的输出语句也会在 import 时自动执行， 这说明 Python 依然会加载并执行模块中的代码 。
使用“from fk_ module import name, hello ” 导入模块中成员的本质就是：将 fk module.py 中的全部代码加载到内存并执行，
然后只导入指定变量、函数等成员单元，并不会将整个模块导入。
    在导入模块后，可 以在模块文件所在目录下看到一个名为 “__pycache__”的文件夹，打开该
文件夹，可以看到 Python 为每个模块都生成一个 ＊.cpython-36.pyc 文件， 比如 Python 为 fk_module
模块生成一个 fk_module.cpython-36.pyc 文件，该文件其实是 Python 为模块编译生成的字节码，用于提升该模块的运行效率。

模块的__all__ 变量：
    在默认情况下 ， 如果使用“from 模块名 import *”这样的语句来导入模块，程序会导入该模块
中所有不以下画线开头的程序单元，这是很容易想到的结果。
    有时候模块中虽然包含很多成员，但并不希望每个成员都被暴露出来供外界使用，此时可借助
于模块的 all 变量，将变量的值设置成一个列表，只有该列表中的程序单元才会被暴露出来 。
