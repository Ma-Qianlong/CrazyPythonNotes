# 线程同步
        多线程编程是一件有趣的事情，它很容易突然出现“错误情况”，这是由系统的线程调度具有
一定的随机性造成的。 不过， 即使程序偶然 出现问题，那也是由于编程不当引起的。当使用多个线
程来访 问同一个数据时，很容易“偶然”出现线程安全问题。

## 1. 线程安全问题
    关于线程安全， 有一个经典的问题——银行取钱问题 。
        Account.py  draw_thread.py

## 2. 同步锁（Lock）
    draw_thread.py 出现错误结果 ，是因为 run（）方法的方法体不具有线程安全性——程序
中有两个并发线程在修改 Account 对象：而且系统恰好在粗体字代码处执行线程切换 ，切换到另一
个修改 Account 对象的线程，所以就出现了问题。
    为了解决这个问题， Python 的 threading 模块引入了锁（ Lock ） 。 threading 模块提供了 Lock 和
RLock 两个类，它们都提供了如下两个方法来加锁和释放锁。
    >>  acquire(blocking=True, timeout=-1)： 请求对 Lock 或 RLock 加锁，其中 timeout 参数指定加锁多少秒。
    >>  releas()：释放锁。
        Lock 和 RLock 的 区别如下 。
    >>  threading.Lock：它是一个基本的锁对象，每次只能锁定一次，其余的锁请求，需等待锁释放后才能获取。
    >>  threading.RLock：它代表可重入锁（Reentrant Lock）。对于可重入锁，在同一个线程中可以对它进行多次锁定，
        也可以多次释放。如果使用RLock，那么 acquire（）和 release（）方法必须成对出现。
        如果调用了 n 次 acquire（）加锁，则必须调用 n 次 release（）才能释放锁。

    由此可见， RLock 锁具有可重入性。 也就是说，同 一个线程可以对己被加锁的 RLock 锁再次加锁，
RLock 对象会维持一个计数器来追踪 acquire（）方法的嵌套调用，线程在每次调用 acquire（）加
锁后，都必须显式调用 release（）方法来释放锁 。 所以， 一段被锁保护的方法可以调用另一个被相同
锁保护的方法。
    Lock 是控制多个线程对共享资源进行访问的工具。 通常，锁提供了对共享资源的独占访问，
每此只能有一个线程对 Lock 对象加锁， 线程在开始访问共享资源之前应先请求获得 Lock 对象。
当对共享资源访问完成后，程序释放对 Lock 对象的锁定。

    在实现线程安全的控制中 ，比较常用的是 RLock。通常使用 RLock 的代码格式如下 ：
    class X:
        ＃定义需要保证线程安全的方法
        def m() :
            ＃加锁
            self.lock.acquire()
            try :
                ＃需要保证线程安全的代码
                ＃． ． ． 方法体
            ＃使用 finally 块来保证释放锁
            finally :
                ＃修改完成，释放锁
                self.lock.release()

    使用 RLock 对象来控制线程安全，当加锁和释放锁出现在不同的作用范围内时，通常建议使
用 finally 块来确保在必要时释放锁。

    通过使用 Lock 对象可以非常方便地实现线程安全的类，线程安全的类具有如下特征。
    〉该类的对象可以被多个线程安全地访问。
    〉每个线程在调用该对象的任意方法之后，都将得到正确的结果。
    〉每个线程在调用该对象的任意方法之后，该对象都依然保持合理的状态。

    总的来说，不可变类总是线程安全的， 因为它的对象状态不可改变； 但可变对象需要额外的方
法来保证其线程安全。例如，上面的 Account 就是一个可变类，它的 self.account_no 和 self._balance
（为了更好地封装，将 balance 改名为 _balance ）两个成员变量都可以被改变，当两个钱程同时修改
Account 对象的 self._balance 成员变量的值时，程序就出现了异常。下面将 Account 类对 self._balance
的访问设置成线程安全的， 那么只需对修改 self._balance 的方法增加线程安全的控制即可。
    将 Account 类改为如下形式， 它就是线程安全的。

        Lock\Account.py  Lock\draw_test.py

     可变类的线程安全是以降低程序的运行效率作为代价的，为了减少线程安全所带来的负面影响，
程序可以采用如下策略。
    》不要对线程安全类的所有方法都进行同步，只对那些会改变竞争资源（竞争资源也就是共
    享资源）的方法进行同步。 例如，上面 Account 类中的 account_no 实例变量就无须同步，
    所以程序只对 draw（）方法进行了同步控制。
    》如果可变类有两种运行环境： 单线程环境和多线程环境， 则应该为该可变类提供两种版本，
    即线程不安全版本和线程安全版本。在单线程环境中使用钱程不安全版本以保证性能，在
    多线程环境中使用线程安全版本。

## 3 死锁

    当两个线程相互等待对方释放同步监视器时就会发生死锁。 Python 解释器没有监测， 也没有
采取措施来处理死锁情况， 所以在进行多线程编程时应该采取措施避免出现死锁。一旦出现死锁，
整个程序既不会发生任何异常， 也不会给出任何提示，只 是所有线程都处于阻塞状态，无法继续。
死锁是很容易发生的，尤其是在系统中出现多个同步监视器的情况下，如下程序将会出现死锁。

    dead_lock.py

    死锁是不应该在程序中出现的，在编写程序时应该尽量避免出现死锁 。 下面有几种常见的方式
用来解决死锁问题
    >> 避免多次锁定： 尽量避免同一个线程对多个 Lock 进行锁定。 例如上面的死锁程序，主线
    程要对 A 、 B 两个对象的 Lock 进行锁定 ， 副线程也要对 A 、 B 两个对象的 Lock 进行锁定，
    这就埋下了导致死锁的隐患 。
    >> 具有相同的加锁顺序 ：如果多个线程需要对多个 Lock 进行锁定， 则应该保证它们以相同
    的顺序请求加锁 。 比如上面的死锁程序，主线程先对 A 对象的 Lock 加锁，再对 B 对象 的
    Lock 加锁；而副线程则先对 B 对象的 Lock 加锁， 再对 A 对象的 Lock 加锁 。 这种加锁顺
    序很容易形成嵌套锁定，进而导致死锁 。 如果让主线程、副线程按照相同的顺序加锁，就
    可以避免这个问题 。
    >> 使用定时锁 ： 程序在调用 acquire（）方法加锁时可指定 timeout 参数，该参数指定超过 timeout
    秒后会自动释放对 Lock 的锁定，这样就可以解开死锁了 。
    >> 死锁检测：死锁检测是一种依靠算法机制来实现的死锁预防机制，它主要是针对那些不可
    能实现按序加锁，也不能使用定时锁的场景的 。
