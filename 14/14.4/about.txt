# 控制线程
    Python 的线程支持提供了一些便捷的工具方法， 通过这些工具方法可以很好地控制线程的执行。

## 1. join线程
    Thread 提供了让一个线程等待另一个线程完成的方——join（）方法。当在某个程序执行流中
调用其他线程的 join（）方法时，调用线程将被阻塞，直到被 join（）方法加入的 join 线程执行完成。
join（）方法通常由使用线程的程序调用，以将大问题划分成许多小问题，并为每个小问题分配
一个线程。当所有的小问题都得到处理后，再调用主线程来进一步操作。
    join(timeout=None）方法可以指定一个 timeout 参数，该参数指定等待被 join 的线程的时间最长
为 timeout 秒。 如果在 tim巳out ;fj; 内被 join 的线程还没有执行结束 ，则不再等待。

        join_thread.py

## 2. 后台线程
    有一种线程，它是在后台运行的，它的任务是为其他线程提供服务，这种线程被称为 “ 后台线
程（ Daemon Thread ）”， 又称为“守护线程”或“精灵线程 ”。 Python 解释器 的垃圾回收线程就是
典型的后台线程 。
    后台线程有一个特征 ： 如果所有的前台线程都死亡了，那么后台线程会自动死亡。
    调用 Thread 对象 的 daemon 属性可以将指定线程设置成后台线程。下面程序将指定线程设置成
后台线程，可以看到当所有的前台线程都死亡后，后台线程随之死亡。当在整个虚拟中几中只剩下后
台线程时，程序就没有继续运行的必要了，所以程序也就退出了 。

        daemon_thread.py

    创建后台线程有两种方式 。
    》主动将线程的 daemon 属性设置为 True 。
    》后台线程启动的线程默认是后台线程 。

    ***
        当前台线程死亡后， Python 解释器会通知后台线程死亡，但是从它接收指令到
    做出响应需要一定的时间。如果要将某个线程设置为后台线程，则必须在该线程启动
    之前进行设直。也就是说，将 daemon 属性设为 True ，必须在 start（）方法调用之前进
    行，否则会引发 RuntimeError 异常 。
    ***

## 3. 线程睡眠：sleep
    如果需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用 time 模块
的 sleep(secs）函数来实现。该函数可指定一个 secs 参数，用于指定线程阻塞多少秒。
    当当前线程调用 sleep（）函数进入阻塞状态后，在其睡眠时间段内，该线程不会获得执行的机会，
即使系统中没有其他可执行的线程，处于 sleep（）中的线程也不会执行，因此 sleep（）函数常用来暂停
程序的运行。
    下面程序调用 sleep（）函数来暂停主线程的执行，因为该程序只有一个主线程，当主线程进入睡
眠后，系统没有可执行的线程， 所以可以看到程序在 sleep（）函数处暂停。

        sleep_test.py