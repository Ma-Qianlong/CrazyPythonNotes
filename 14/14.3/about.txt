# 线程的生命周期

    当线程被创建并启动 以后，它既不是一启动就进入执行状态的，也不是一直处于执行状态的 ，
在线程的生命周期中，它要经过新建 CN巳w ）、就绪（ Ready ）、运行（ Running ）、 阻塞（ Blocked )
和死亡（ Dead) 5 种状态。尤其是当线程启动以后，它不可能－直“霸占”着 CPU 独自运行，所
以 CPU 需要在多个线程之间切换，于是线程状态也会多次在运行、就绪之间转换 。

## 1. 新建和就绪状态
    当程序创建了一个 Thread 对象或 Thread 子类的对象之后，该线程就处于新建状态，和其他的
Python 对象一样，此时的线程对象并没有表现出任何线程的动态特征，程序也不会执行线程执行体 。
    当线程对象调用 start（）方法之后，该线程处于就绪状态， Python 解释器会为其创建方法调用技
和程序计数器，处于这种状态中的线程并没有开始运行，只是表示该线程可以运行了。 至于该线程
何时开始运行，取决于 Python 解释器中线程调度器的调度。

           invoke_run.py

    在调用线程对象的 start（）方法之后，该线程立即进入就绪状态——相当于“等待执行”，但该
线程并未真正进入运行状态。

## 2. 运行和阻塞状态
    如果处于就绪状态的线程获得了 CPU，开始执行 run（）方法的线程执行体，则该线程处于运行
状态。如果计算机只有一个 CPU，那么在任何时刻只有一个线程处于运行状态。当然，在一个具
有多处理器的机器上，将会有多个线程并行（ Parallel ）执行；当线程数大于处理器数时，依然会
存在多个线程在同一个 CPU 上轮换的情况 。
    当一个线程开始运行后，它不可能一直处于运行状态（除非它的线程执行体足够短，瞬间就执
行结束了），线程在运行过程中需要被中断，目的是使其他线程获得执行的机会，线程调度的细节
取决于底层平台所采用的策略。对于采用抢占式调度策略的系统而言，系统会给每一个可执行的线
程一个小时间段来处理任务；当该时间段用完后，系统就会剥夺该线程所占用的资源，让其他线程
获得执行的机会。在选择下一个线程时，系统会考虑线程的优先级 。
    所有现代的桌面和服务器操作系统都采用抢占式调度策略，但一些小型设备如手机等则可能采
用协作式调度策略，在这样的系统中，只有当一个线程调用了它的 sleep（）或 yield（）方法后才会放弃
其所占用的资源——也就是必须由该线程主动放弃其所占用的资源。
    当发生如下情况时，线程将会进入阻塞状态。
    》线程调用 sleep（）方法主动放弃其所占用的处理器资源 。
    》线程调用了 一个阻塞式 I/O 方法，在该方法返回之前，该线程被阻塞 。
    》线程试图获得一个锁对象，但该锁对象正被其他线程所持有。 关于锁对象的知识，后面将有更深入的介绍 。
    》线程在等待某个通知（ Notify ）。
    当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会 。 被阻塞的线程会在合适的
    时候重新进入就绪状态，注意是就绪状态，而不是运行状态 。 也就是说，被阻塞线程的阻塞解除后，
    必须重新等待线程调度器再次调度它 。
    针对上面几种情况，当发生如下特定的情况时可以解除阻塞，让该线程重新进入就绪状态。
    》调用 sleep（）方法的线程经过了指定的时间 。
    》线程调用的阻塞式 I/O 方法己经返回。
    》线程成功地获得了试图获取的锁对象 。
    》线程正在等待某个通知时，其他线程发出了一个通知 。

## 3. 线程死亡
    程会以如下三种方式结束，结束后就处于死亡状态。
    》run（）方法或代表线程执行体的 target 函数执行完成，线程正常结束 。
    》线程抛出一个未捕获的 Exception 或 Error 。

    **** 注意：
    当主线程结束时，其他线程不受任何影响，并不会随之结束。 一旦子线程启动起
    来后，它就拥有和主线程相同的地位，它不会受主线程的影响。
    ****

    为了测试某个线程是否己经死亡，可以调用线程对象的 is_alive（）方法，当线程处于就绪、运
行、阻塞三种状态时，该方法将返回 True ； 当线程处于新建、死亡两种状态时，该方法将返回 False 。

    **** 注意：
    不要试图对一个已经死亡的线程调用 start（）方法使它重新启动，死亡就是死亡，
    该线程将不可再次作为线程运行。
    不要对处死亡状态的线程调用 start（）方 法 ，程序只能对处于新建状态的线程调
    用 start（）方；对于处于新建才犬态的线程两次调用 start（）方法也是错误的 。 它们都会引发 RuntimeError 异常。
    ****

        start_dead.py (尝试对处于死亡状态的线程再次调用 start（）方法)